% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ip_to_integer.R
\name{ip_to_integer}
\alias{ip_to_integer}
\alias{integer_to_ip}
\title{Represent address as integer}
\usage{
ip_to_integer(x)

integer_to_ip(x, is_ipv6 = NULL)
}
\arguments{
\item{x}{\itemize{
\item For \code{ip_to_integer()}: An \code{\link{ip_address}} vector
\item For \code{integer_to_ip()}: A \code{\link[bignum:biginteger]{bignum::biginteger}} vector
}}

\item{is_ipv6}{A logical vector indicating whether to construct an IPv4 or
IPv6 address. If \code{NULL} (the default), then integers less than 2^32 will
construct an IPv4 address and anything larger will construct an IPv6 address.}
}
\value{
\itemize{
\item For \code{ip_to_integer()}: A \code{\link[bignum:biginteger]{bignum::biginteger}} vector
\item For \code{integer_to_ip()}: An \code{\link{ip_address}} vector
}
}
\description{
Encode or decode an \code{\link{ip_address}} as an integer.
}
\details{
It is common to represent an IP address as an integer, by reinterpreting
the bit sequence as a big-endian unsigned integer. This means IPv4 and IPv6
addresses can be represented by 32-bit and 128-bit unsigned integers.
In this way, the IPv4 addresses \verb{0.0.0.0} and \verb{255.255.255.255} would be
represented as 0 and 4,294,967,295.
}
\examples{
x <- ip_address(c("192.168.0.1", "2001:db8::8a2e:370:7334", NA))
ip_to_integer(x)

integer_to_ip(ip_to_integer(x))

# with IPv4 only, we can use numeric data type
as.numeric(ip_to_integer(ip_address("192.168.0.1")))

integer_to_ip(3232235521)
}
\seealso{
\itemize{
\item \code{\link[=ip_to_bytes]{ip_to_bytes()}} and \code{\link[=bytes_to_ip]{bytes_to_ip()}}
\item \code{\link[=ip_to_binary]{ip_to_binary()}} and \code{\link[=binary_to_ip]{binary_to_ip()}}
}
}
